1. コマンドラインから値を取得する。
2. ファイル内のデータをセット
3. マップ構成要素の確認
    1. プレイヤーがいるか
        1. プレイヤーの位置をセット
        2. プレイヤーの角度をセット
    2. マップの完全性を確認（深さ優先探索を用いて確認あ）
4. mlx関数を用いて初期描画
5. レンダリング関数
    1. 新規イメージの生成
    2. ゆかと床と天井の描画
    3. レイキャスティング
        1. next_grid_distance_y / x
        2. increment_ray_length
        3. check_wall
        4. wall_collision
        5. wall_point
    4. 壁の描画
    5. ミニマップの描画
6. key_pressする
    1. handle_movement
    2. handle_left_angle
    3. handle_right_angle
    4. [5. レンダリング関数]
    5. ミニマップの移動
7. イベントループ、終了処理


## Cub3D プロジェクト 主要データフローと処理ステップ

本セクションでは、Cub3Dプログラムの主要なデータフローと処理ステップを詳細に記述します。

**1. コマンドライン引数からの情報取得**

- **目的**: プログラム実行時に必要な設定ファイルへのパスを取得する。
- **詳細**: プログラムはコマンドライン引数として、シーン記述ファイル（`.cub`拡張子）へのパスを1つ受け取る必要がある。

**2. 設定ファイル内のデータのセットアップ**

- **目的**: プログラムの実行に必要なテクスチャ、色、マップデータを設定ファイルから読み込み、プログラム内のデータ構造に格納する。
- **詳細**: `.cub` ファイルをパースし、以下の情報を抽出・格納する。
    - 壁テクスチャのパス (東西南北: NO, SO, WE, EA)。
    - 床の色 (F) および天井の色 (C) をRGB値で指定し、対応するデータ構造（例えば`textures.sky_hex`, `textures.floor_hex`）に変換・格納する。RGB値は0-255の範囲である。
    - マップデータを抽出する。マップデータはファイルの一番最後に記述される [要件]。

**3. マップ構成要素の確認と初期設定**

- **目的**: 読み込んだマップデータがゲームの要件を満たしているか確認し、プレイヤーの初期位置と向きを設定する。
    - **3.1. プレイヤーの存在確認と初期設定**
        - **目的**: マップ内にプレイヤーの開始地点が正しく設定されているか確認し、位置と向きを設定する。
        - **詳細**: マップデータ中にプレイヤーの開始地点を示す文字 ('N', 'S', 'E', 'W') が1つだけ存在する必要がある [54, 要件]。
            - **3.1.1. プレイヤーの位置をセット**
                - **目的**: マップ上のプレイヤー開始地点の座標をプログラム内のプレイヤー位置データに設定する。
                - **詳細**: マップデータ中の 'N', 'S', 'E', 'W' の文字のグリッド座標をプレイヤーの初期位置として設定する。位置は浮動小数点数で管理され、グリッドの中心（例: 整数座標に0.5を加算）が使用されることが多い。
            - **3.1.2. プレイヤーの角度をセット**
                - **目的**: プレイヤー開始時の向き（東西南北）に基づき、視線方向とカメラ平面を設定する。
                - **詳細**: プレイヤーの向き ('N', 'S', 'E', 'W') に応じて、プレイヤーの方向ベクトル (`dirX`, `dirY`) とカメラ平面ベクトル (`planeX`, `planeY`) の初期値を設定する。例えば、北向き ('N') なら `dirY` は負の値、カメラ平面はX軸方向になるように設定する。カメラ平面ベクトルは常に方向ベクトルに垂直である。これらのベクトルは、その後のレイキャスティングやプレイヤーの移動/回転計算に使用される。
    - **3.2. マップの完全性確認**
        - **目的**: 読み込んだマップが構造的な要件（壁で囲まれているなど）を満たしているか検証する。
        - **詳細**:
            - マップは必ず壁 ('1') で完全に囲まれている必要がある [要件, 54]。
            - マップ内に無効な文字（'0', '1', 'N', 'S', 'E', 'W', スペース以外の文字）が含まれていないか確認する [要件, 54]。
            - プレイヤーの開始地点がマップ内に1つだけ存在するか確認する [要件, 54]。
            - マップ内の空間 ('0') またはプレイヤー開始地点の周囲8方向（斜めを含む）にスペースやタブがないか確認する。これにより、空間が閉じられている（壁や他のタイルで囲まれている）ことを保証する [要件]。
            - (深さ優先探索によるマップの閉鎖性検証 - ソースに直接的な記述はありませんが、マップ完全性の一般的な確認方法として考えられます。)
            - これらの検証で問題が見つかった場合、「Error\n」に続けて具体的なエラーメッセージを出力し、プログラムを終了する [要件, 4]。

**4. MiniLibXを用いた初期描画**

- **目的**: ゲームウィンドウを作成し、最初のフレームを描画する準備をする。
- **詳細**: MiniLibXライブラリの関数（例: `mlx_init`, `mlx_new_window`, `mlx_new_image`）を使用して、ウィンドウを作成し、描画用のイメージバッファを生成する。

**5. レンダリング関数（フレームごとの描画処理）**

- **目的**: プレイヤーの現在の位置と視点に基づいて、ゲームの世界の3D表示を計算し、画面に描画する。この処理はゲームのメインループ内で毎フレーム実行される。
    - **5.1. 新規イメージの生成とバッファクリア**
        - **目的**: 各フレームの描画のために新しい描画バッファを準備し、前のフレームの描画内容を消去する。
        - **詳細**: 新しいイメージバッファを生成するか、既存のバッファをクリアする。MiniLibXでは、新しいイメージを生成し、描画後にそれをウィンドウにプッシュする方法や、既存イメージのピクセルバッファを直接操作する方法がある。
    - **5.2. 床と天井の描画**
        - **目的**: ゲーム空間の床と天井の色またはテクスチャを描画する。
        - **詳細**: 画面を水平方向（地平線）で上下に分け、上半分を指定された天井の色/テクスチャで、下半分を指定された床の色/テクスチャで塗りつぶす。テクスチャを使用する場合、透視投影（パースペクティブコレクト）されたテクスチャ座標を計算する必要がある。この処理は通常、壁のレイキャスティングのループの前か、または同じループ内で行われる。
    - **5.3. レイキャスティング**
        - **目的**: 画面の各垂直列に対してレイを飛ばし、最も近い壁までの距離と壁の情報を取得する。
        - **詳細**: 画面の左端から右端までの各X座標（垂直列）に対して、以下の処理を繰り返す。
            - **5.3.1. レイの計算と初期データ設定 (`set_ray_data`相当)**
                - **目的**: 現在処理している画面のX座標に対応するレイの方向を計算し、DDAアルゴリズムに必要な初期値を設定する。
                - **詳細**: 画面X座標をカメラ平面上の座標に変換し (`cameraX`)、プレイヤーの方向ベクトルとカメラ平面ベクトルを用いてレイの方向ベクトル (`rayDirX`, `rayDirY`) を計算する。レイの開始マップ座標 (`mapX`, `mapY`) をプレイヤーの現在位置から取得する. X方向とY方向に1マップユニット進むのに必要な距離 (`deltaDistX`, `deltaDistY`) を計算する。これはレイの方向ベクトルの成分の逆数の絶対値に比例する. レイの成分が0の場合は非常に大きな値を設定する.
            - **5.3.2. ステップ方向と最初のグリッド境界までの距離の計算 (`calculate_step_x_direction`, `calculate_step_y_direction`相当)**
                - **目的**: レイが進むべき方向（X/Y軸の正または負）を決定し、プレイヤー位置から最初のX/Yグリッド境界までの距離を計算する。
                - **詳細**: レイの方向ベクトル (`rayDirX`, `rayDirY`) の符号に基づき、マップ座標を増減させるステップ方向 (`stepX`, `stepY`: +1 または -1) を決定する。プレイヤーの位置と最初のグリッド境界までの距離に `deltaDistX`, `deltaDistY` を乗算して、最初のX/Yグリッド境界に到達するまでの距離 (`sideDistX`, `sideDistY`) を計算し初期設定する.
            - **5.3.3. DDAアルゴリズムの実行 (`get_nearest_axis`, `perform DDA`相当)**
                - **目的**: レイをマップ上で1グリッドずつ進め、壁に衝突するまで探索する。
                - **詳細**: 壁に衝突する (`hit == 1`) までループを繰り返す。ループ内では、`sideDistX` と `sideDistY` を比較し、小さい方の距離に対応する方向にレイを1ステップ進める (`mapX += stepX` または `mapY += stepY`)。進んだ方向 (`side`: X軸側なら0, Y軸側なら1) を記録する。対応する `sideDist` に `deltaDist` を加算して更新する. 更新されたマップ座標が壁 ('1'または'>0') であるか判定し (`is_hit_wall`)、壁であれば `hit` フラグを立ててループを終了する.
            - **5.3.4. 壁までの距離計算 (`perpWallDist`)**
                - **目的**: プレイヤーから壁までの垂直距離を正確に計算し、魚眼効果を防ぐ。
                - **詳細**: DDAループ終了後に、壁に当たったグリッド位置 (`mapX`, `mapY`)、ステップ方向 (`stepX`, `stepY`)、壁に当たった方向 (`side`)、および`sideDist`/`deltaDist`の値を用いて、プレイヤーから壁までの垂直距離 (`perpWallDist`) を計算する。計算式は、壁に当たった側の `sideDist` から対応する `deltaDist` を一度引いた値になる。
            - **5.3.5. ヒットした壁のテクスチャ座標計算 (`wall_point`, `get_hit_wall_x`相当)**
                - **目的**: レイが壁に当たった地点が、壁テクスチャ上のどの位置（水平方向）に対応するかを計算する。
                - **詳細**: `perpWallDist` を用いて、壁のヒット地点のワールド座標系での位置を計算し (`wallX`)。この値を正規化することで、壁テクスチャ上の0.0から1.0の範囲の座標 (`wallX`) を得る。この正規化された座標にテクスチャの幅を乗算し、テクスチャ上のX座標 (`texX`) を計算する。壁が東西南北のどちら側であるか、およびレイの方向によって、テクスチャ座標を反転させる補正が必要になる場合がある.
    - **5.4. 壁の描画**
        - **目的**: 計算した情報（壁までの距離、テクスチャ座標、ヒットした壁の向き）に基づき、画面上の対応する垂直列に壁を描画する。
        - **詳細**: `perpWallDist` を使用して、画面上に描画すべき壁の垂直方向の高さ (`lineHeight`) を計算する. `lineHeight` と画面の高さに基づいて、壁を描画する画面上の開始Y座標 (`drawStart`) と終了Y座標 (`drawEnd`) を計算する. マップ上の壁の種類やヒットした壁の向き (`side`) に基づいて、使用するテクスチャ (`texNum`) を決定する. `drawStart` から `drawEnd` までの各Y座標（ピクセル）に対して、壁のテクスチャ座標の垂直方向 (`texY`) を計算する. `texX` と `texY` を用いてテクスチャから色を取得し (`get_texel_image`相当)、画面バッファの対応するピクセルに色を書き込む. Y軸に平行な壁（南北の壁）の色は、東西の壁よりも暗くする処理がよく行われる. スプライト描画のために、この列の `perpWallDist` をZバッファに格納する.
    - **5.5. ミニマップの描画 (ボーナス機能)**
        - **目的**: ゲームの世界の2Dマップ（ミニマップ）上に、プレイヤーの位置や視界を表示する。
        - **詳細**: (ソースに直接的な実装方法は記述されていませんが、ボーナス機能として挙げられています [要件]) プレイヤーの現在位置と視界範囲を2Dマップ上に重ねて描画することで実現される可能性があります。
    - **(スプライトの描画 - ボーナス機能)**:
        - **目的**: ゲーム空間内のスプライト（樽や敵など）を3D空間に配置し、画面に描画する。
        - **詳細**: (ソースに詳細な実装が記述されていますが、ユーザーリストには含まれていませんでした。概要のみ記述します。) スプライトをプレイヤーからの相対座標に変換し、カメラ行列の逆行列を用いてカメラ空間座標に変換する. スプライトのスクリーン上の位置とサイズを計算し、Zバッファを用いた深度判定を行い、スプライトのテクスチャを画面に描画する. 複数のスプライトがある場合は、奥にあるものから順に描画するためにソートが必要になる.

**6. キー入力処理 (`key_press`イベント)**

- **目的**: プレイヤーからのキーボード入力を検知し、ゲーム内のアクション（移動、視点変更）に反映させる。
- **詳細**: MiniLibXのキーイベントハンドリング関数（例: `mlx_key_hook`や`mlx_loop_hook`内でキーの状態を確認）を使用して、キー入力を処理する.
    - **6.1. 移動処理 (`handle_movement`, `controle_player`相当)**
        - **目的**: WASDキーに応じてプレイヤーを移動させる。
        - **詳細**: WASDキーが押されているか確認し、プレイヤーの方向ベクトル (`dirX`, `dirY`) やカメラ平面ベクトル (`planeX`, `planeY`) を用いて移動先の候補座標を計算する. 移動先の座標がマップ上の壁 ('1'または'>0') でないか衝突判定を行い、壁でなければプレイヤーの現在位置 (`posX`, `posY`) を更新する. 速度はフレームレートに依存しないように調整する.
    - **6.2. 左回転処理 (`handle_left_angle`)**
        - **目的**: 左矢印キーまたはマウス操作に応じてプレイヤーの視点を左に回転させる。
        - **詳細**: 左矢印キーまたはマウスが左方向に動いたことを検知し、プレイヤーの方向ベクトル (`dirX`, `dirY`) とカメラ平面ベクトル (`planeX`, `planeY`) を回転行列を用いて左方向に回転させる. 回転角度はフレームレートに依存しないように調整する.
    - **6.3. 右回転処理 (`handle_right_angle`)**
        - **目的**: 右矢印キーまたはマウス操作に応じてプレイヤーの視点を右に回転させる。
        - **詳細**: 右矢印キーまたはマウスが右方向に動いたことを検知し、プレイヤーの方向ベクトル (`dirX`, `dirY`) とカメラ平面ベクトル (`planeX`, `planeY`) を回転行列を用いて右方向に回転させる. 回転角度はフレームレートに依存しないように調整する.
    - **6.4. 画面の再レンダリング**
        - **目的**: プレイヤーの位置や視点が変更された場合、ゲーム画面を更新するためにレンダリング関数を再度呼び出す。
        - **詳細**: 移動または回転処理が行われた後に、ステップ5のレンダリング関数を呼び出し、新しいプレイヤーの状態に基づいた画面を描画する.
    - **6.5. ミニマップの移動 (ボーナス機能)**
        - **目的**: プレイヤーが移動した場合、ミニマップ上のプレイヤー位置表示を更新する。
        - **詳細**: (ソースに直接的な記述はありません。) プレイヤーの位置更新に合わせて、ミニマップ上のプレイヤー表示を更新する処理を行う。

**7. イベントループと終了処理**

- **目的**: ゲームのメインループを開始し、キー入力やウィンドウイベントを継続的に処理し、適切なタイミングでプログラムを終了させる。
- **詳細**: MiniLibXのイベントループ関数（例: `mlx_loop`) を開始する。このループ内で、登録されたキー入力、ウィンドウイベント（ウィンドウを閉じるボタンのクリックなど）、およびフレームごとのレンダリング処理が実行される.
    - ESCキー押下 またはウィンドウフレームの赤い×ボタンのクリック を検知した場合、MiniLibXのリソースを解放するなどのクリーンアップ処理を行い、プログラムを終了する。
    - エラー発生時も同様に、リソースを解放し、エラーメッセージを出力して終了する必要がある [4, 要件]。